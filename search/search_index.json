{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"My Own Runbooks","text":"<p>Use this to capture some useful notes during my day-to-day work.</p> <p>It's created with mkdocs.org, visit the website to see more details of it.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#setup","title":"Setup","text":"<pre><code>mkdocs new runbooks\nmkdocs get-deps\npip install mkdocs-material\nmkdocs serve\n</code></pre> <p>After the server starts, you can access the docs via http://localhost:8000</p>"},{"location":"#deploy-as-github-pages","title":"Deploy as github pages","text":"<p>Refer to mkdocs: deploy your docs</p> <pre><code># run this at the root of the repo\nmkdocs gh-deploy \n</code></pre> <p>After it's done, you can access the webiste with github-page/runbooks, or with other configurations: mingliang.me/runbooks.</p>"},{"location":"cloud/gcp/gcp-auth/","title":"GCP Auth","text":""},{"location":"cloud/gcp/gcp-auth/#login-with-gcp-cli-and-set-quota-project","title":"Login with GCP CLI And set quota project","text":"<pre><code>gcloud auth application-default login\ngcloud auth application-default set-quota-project my-awesome-project\n</code></pre> <p>You need to authenticate with GCP first before setting the quota project.</p>"},{"location":"data-infra/data-infra/","title":"Data Infrastructures","text":"<ul> <li>dbt</li> </ul>"},{"location":"data-infra/dbt/","title":"DBT","text":""},{"location":"data-infra/dbt/#dbt-cheat-sheet","title":"DBT cheat-sheet","text":"<ul> <li>https://datacoves.com/post/dbt-jinja-functions-cheat-sheet</li> </ul>"},{"location":"design/design/","title":"Design","text":""},{"location":"design/design/#learn-wireframe","title":"Learn wireframe","text":"<ul> <li>why? What? Who? How?</li> </ul>"},{"location":"devops/secrets/generate_random_secrets/","title":"Generate random secrets","text":"<ul> <li>Use this handy website: Random key generator</li> <li>use <code>openssl rand -hex 32</code></li> <li>https://generate-secret.vercel.app/32</li> </ul>"},{"location":"devops/ssl/generate_ssl_key_pairs/","title":"Generate SSL Key pairs for Https","text":""},{"location":"devops/ssl/generate_ssl_key_pairs/#steps-to-generate-the-key-pairs","title":"Steps to generate the key pairs","text":"<pre><code>openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout key.pem -days 366\n</code></pre> <p>After running the command above, it generates two files:</p> <ul> <li>cert.pem</li> <li>cert.pem</li> </ul> <p>These files will be used for your app as a self-signed key pairs.</p> <p>For example, a python FASTAPI service can use the self-signed certs as following(assuming the path is correct):</p> <pre><code>if __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", reload=True, port=8000, host=\"0.0.0.0\", ssl_keyfile=\"./certs/key.pem\",\n                ssl_certfile=\"./certs/cert.pem\")\n</code></pre>"},{"location":"devops/vagrant/","title":"Vagrant","text":""},{"location":"devops/vagrant/#vagrant-for-m1-macos","title":"Vagrant for M1 MacOS","text":"<p>There are two common options to run vagrant on Mac:</p> <ul> <li>VMWare Fusion as provider</li> <li>references: Installing Vagrant on Apple Silicon Macs (M1, M1X, etc)</li> <li>qemu as provider</li> <li>references: Do M1 Mac Dream of x86 Linux?</li> </ul> <p>The following example shows how to use qemu as the provider:</p> <pre><code>brew install qemu\nvagrant plugin install vagrant-qemu\nvagrant init -m perk/ubuntu-22.10-arm64\nvagrant up\n</code></pre>"},{"location":"dotfiles/dotfiles/","title":"Dotfiles management","text":"<ul> <li>yadm</li> </ul> <p>It's a very handy tools and works quite similar to git.</p>"},{"location":"macos/macos/","title":"MacOS","text":""},{"location":"macos/macos/#collection-of-nice-tools-on-macos","title":"Collection of nice tools on MacOS","text":"<ul> <li>Open Source Mac Apps</li> </ul>"},{"location":"macos/macos/#window-management","title":"Window management","text":"<ul> <li>divvy</li> <li>rectangle</li> </ul> <p>Divvy is the one I have been using for years. It's good enough, not sure if it's worth to try something different. Heard some good words about <code>rectangle</code>, and also swish, which is a paid software.</p>"},{"location":"macos/macos/#cleanup-tools","title":"Cleanup tools","text":"<ul> <li>CLI: mac-cleanup-py</li> </ul> <pre><code>brew tap mac-cleanup/mac-cleanup-py\nbrew install mac-cleanup-py\nmac-cleanup\n</code></pre> <ul> <li>GUI: PrettyClean</li> <li>lemon-cleanup from Tencent</li> </ul>"},{"location":"python/fastapi/fastapi/","title":"FASTAPI","text":""},{"location":"python/fastapi/fastapi/#useful-links","title":"Useful links","text":"<ul> <li>swagger</li> <li>enable https</li> </ul>"},{"location":"python/fastapi/fastapi/#auth-integration-with-okta","title":"Auth integration with Okta","text":""},{"location":"python/fastapi/fastapi/#validate-tokens-using-jws","title":"Validate tokens using jws","text":"<p>There are two ways to validate the jwt tokens from a web application: - use jws uri to fetch the jwt keyset and use it for the validation     - with this approach, the jws only needs to be fetched once and then uses locally. - invoke the okta introspect : <code>$(baseUrl}/v1/introspect</code> endpoint if it's provided by the oauth provider and validate the token remotely.</p> <p>This article - Build and Secure an API in Python with FastAPI provides an example of both approaches.</p>"},{"location":"webapps/authNZ/auth-cli/","title":"Auth CLI","text":"<pre><code>curl -D 'https://dev-xyz.okta.com/oauth2/v1/token' \\\n-H 'Authorization: Basic base64-encoded-client_id:client_secret' \\\n-H 'content-type: application/x-www-form-urlencoded' \\\n-d 'grant_type=authorization_code' \\\n-d 'redirect_uri=http://localhost:3000' \\\n-d 'code=auth_code'\n</code></pre>"},{"location":"webapps/authNZ/auth-integration/","title":"AuthN/Z integration","text":""},{"location":"webapps/authNZ/auth-integration/#okta-integration","title":"Okta integration","text":"<ul> <li>okta cli</li> </ul>"},{"location":"webapps/authNZ/auth-integration/#install-okta-cli-on-macos","title":"Install okta cli on MacOS","text":"<pre><code>brew install --cask oktadeveloper/tap/okta\n</code></pre> <p>Setup a okta developer account(if not having one)</p> <pre><code>okta register\nokta login\nokta apps create\n</code></pre> <p>Once the okta app is created, the issuer, client ID, and client secret will be stored in an <code>.okta.env</code> file in your current directory.</p>"},{"location":"webapps/authNZ/auth-integration/#oauth-integration-options","title":"OAUTH integration options","text":""},{"location":"webapps/authNZ/auth-integration/#spa-with-okta","title":"SPA with OKTA","text":"<p>See docs from the official website: How Authentication and Authorization Work for SPAs</p>"},{"location":"webapps/authNZ/auth-integration/#okta-auth-related-urls","title":"OKTA Auth related URLs","text":"<ul> <li>well-known url: {Issuer}/.well-known/openid-configuration</li> <li>request userinfo: https://{okta_dev_account}.okta.com/oauth2/default/v1/userinfo</li> </ul> <p>CURL commands:</p> <pre><code>export JWT=your_access_token\ncurl -H \"Authorization: Bearer ${JWT}\" https://${okta_dev_domain}.okta.com/oauth2/default/v1/userinfo\n# get user details\ncurl -v -H \"Authorization: Bearer ${JWT}\"  https://${okta_dev_domain}.okta.com/api/v1/users\n</code></pre>"},{"location":"webapps/authNZ/auth-integration/#okta-token-refresh","title":"Okta token refresh","text":"<ul> <li>React Okta SDK not making refresh token call automatically</li> <li>this link provides the screenshot about okta app setup.</li> </ul>"},{"location":"webapps/authNZ/auth-integration/#return-user-groups-in-okta-oauth-flow","title":"Return user groups in OKTA OAuth flow","text":"<p>According to this No \u2018groups\u2019 scope in the console for the default Authorisation Server</p> <p>By default, Okta doesn't have a <code>groups</code> scope defined, in order to use it and have users' group information returned in the token, you need to define both a scope and a claim for it. Here is the brief steps:</p> <ul> <li>In the authorization server, define a scope named <code>groups</code>, and toggle the option - <code>Include in public metadata</code>.</li> <li>Add a claim named <code>groups</code>, and make it include in <code>access token</code>, and set the filter as <code>matches regex</code> with value <code>.*</code>, and <code>Include in</code> the <code>groups</code> scope.</li> </ul>"},{"location":"webapps/authNZ/auth-integration/#how-okta-react-handles-the-logincallback-request","title":"How okta-react handles the /login/callback request?","text":"<p>In an OAuth flow, when the users finish the authentication flow configured with the oauth provider (here okta), the auth provider will send the request back to the originally configured callback url, i.e. <code>/login/callback</code>. This route is typically mapped to okta-react/src/LoginCallback.tsx. It could be a bit confusing how it works. As it is a purely client-side component, how it's possible to handle the redirect? Actually this is quite a standard implementation in a SPA(single page application) context, where any non-existing URLs are mapped to the default home page (e.g. <code>/</code> or <code>/index.html</code>, etc.), in the default landing page, it has the logic to handle client side routing, where the <code>/login/callback</code> should have been registered to the okta's <code>LoginCallback</code> component.</p>"},{"location":"webapps/authNZ/authNZ/","title":"Authentication and Authorization in Web Applications","text":"<p>There are two different ways to setup AuthNZ flow for a web application. </p>"},{"location":"webapps/authNZ/authNZ/#a-spa-backend-api-configuration-would-require","title":"A SPA + backend API configuration would require","text":"<p>Follow this sample-js-react example from okta for the client side auth integration with okta, where the widget will be responsible for the signing via the okta auth flow and generate the access token in local storage if everything is good.</p> <p>The <code>okta-hosted-login</code> is exactly what we are looking for. It will initiate the login to okta and obtain the access token for subsequent request to the backend services.</p>"},{"location":"webapps/authNZ/authNZ/#a-bundled-monolithic-application","title":"A bundled monolithic application","text":"<p>This will bundle both frontend and backend as a single application. And use the same server to host both backend API and frontend web ui. This is typically how traditional web applications work(PHP/rails/JSP/etc.).</p>"},{"location":"webapps/authNZ/authNZ/#resources","title":"Resources","text":"<ul> <li>OKTA: Add user authentication to your React app</li> <li>Implementing Okta Authentication In React</li> <li>FASTAPI Integration<ul> <li>Build and Secure an API in Python with FastAPI</li> <li>github repo: okta-fastapi</li> <li>Python FastAPI microservice with Okta and OPA</li> </ul> </li> </ul>"},{"location":"webapps/authNZ/oidc/","title":"OIDC","text":"<p>OpenID Connect (OIDC), which is an identity layer on top of the OAuth 2.0 protocol, there are two primary types of login flows: IdP-initiated (Identity Provider initiated) and SP-initiated (Service Provider initiated). These refer to the entity that initiates the authentication process.</p>"},{"location":"webapps/authNZ/oidc/#sp-initiated-service-provider-initiated-login","title":"SP-Initiated (Service Provider Initiated) Login:","text":"<ul> <li>Initiation: This flow begins at the Service Provider (SP). A common example is a user trying to access a protected resource or service and being redirected to the login page.</li> <li>Process:<ul> <li>The user attempts to access a resource on the SP.</li> <li>The SP, recognizing that the user is not authenticated, redirects the user to the Identity Provider (IdP) with an authentication request.</li> <li>The user authenticates with the IdP (e.g., by entering username and password).</li> </ul> </li> <li>Post authentication, the IdP sends an authentication response to the SP (usually an ID token and an access token).<ul> <li>The SP validates the response and grants access to the user.</li> </ul> </li> <li>Advantages: It\u2019s more secure as it can prevent certain types of attacks (like unsolicited login attempts) and is generally the preferred method for initiating single sign-on (SSO) in enterprise settings.</li> </ul>"},{"location":"webapps/authNZ/oidc/#idp-initiated-identity-provider-initiated-login","title":"IdP-Initiated (Identity Provider Initiated) Login:","text":"<ul> <li>Initiation: This flow begins at the IdP. It is used in scenarios where a user is already authenticated with the IdP and wants to access a service or application (SP) without additional login steps.</li> <li>Process:<ul> <li>The user is logged in to the IdP and selects a service to access from a provided list (or is automatically directed to a service upon logging in to the IdP).</li> <li>The IdP creates an authentication response (like an ID token or SAML assertion) and sends it directly to the SP.</li> <li>The SP, which receives the assertion from the IdP, validates it and grants access to the user.</li> </ul> </li> <li>Advantages: It offers convenience for users who are already authenticated and want seamless access to multiple services. It\u2019s commonly used in scenarios where an organization has a central portal through which users can access multiple applications.</li> </ul>"},{"location":"webapps/authNZ/oidc/#security-considerations","title":"Security Considerations:","text":"<p>SP-Initiated Flow: More secure as it ensures the user is going to the intended service provider, reducing the risk of phishing or man-in-the-middle attacks. IdP-Initiated Flow: Can be less secure as it could be vulnerable to certain attacks if not implemented correctly. However, it is still widely used, especially in environments where the IdP is trusted and secure. The choice between IdP-initiated and SP-initiated flows often depends on the specific requirements and security considerations of the organization implementing OIDC.</p>"},{"location":"webapps/css/css/","title":"CSS","text":""},{"location":"webapps/css/css/#references","title":"References","text":"<ul> <li>About HTML semantics and front-end architecture</li> </ul>"},{"location":"webapps/development/development/","title":"Web Development","text":""},{"location":"webapps/development/development/#tooling","title":"Tooling","text":"<ul> <li>Fastest Frontend Tooling</li> <li>a nicely curated list of frontend tooling collections.</li> </ul>"},{"location":"webapps/reactjs/reactjs/","title":"ReactJS","text":""},{"location":"webapps/reactjs/reactjs/#state-management","title":"State Management","text":"<ul> <li>zustand</li> </ul>"},{"location":"webapps/reactjs/reactjs/#useful-resources","title":"Useful resources","text":"<ul> <li>reactjs interview questions</li> </ul>"},{"location":"webapps/reactjs/nextjs/nextjs-error-handling/","title":"NextJS Error Handling","text":"<p>Some concepts to be aware of:</p> <ul> <li>error.tsx</li> <li>global-error.tsx</li> <li>ErrorBoundary</li> </ul> <p>global-error.js is only enabled in production. In development, our error overlay will show instead.</p>"},{"location":"webapps/reactjs/nextjs/nextjs-error-handling/#resources","title":"Resources","text":"<ul> <li>NextJS: Handling Errors</li> </ul>"},{"location":"webapps/reactjs/nextjs/nextjs-next-auth-integration/","title":"NextAuth with NextJS","text":"<p>There is a sample application in the NextAuth github repository. It's a bit out-dated, but should be still helpful when needed. There is also a live demo of the sample app: next-auth-example.vercel.app</p>"},{"location":"webapps/reactjs/nextjs/nextjs-next-auth-integration/#configuration-options","title":"Configuration Options","text":"<ul> <li>https://next-auth.js.org/configuration/options</li> </ul> <p>// Choose how you want to save the user session.  // The default is <code>\"jwt\"</code>, an encrypted JWT (JWE) stored in the session cookie.  // If you use an <code>adapter</code> however, we default it to <code>\"database\"</code> instead.  // You can still force a JWT session by explicitly defining <code>\"jwt\"</code>.  // When using <code>\"database\"</code>, the session cookie will only contain a <code>sessionToken</code> value,  // which is used to look up the session in the database.  strategy: \"database\",</p>"},{"location":"webapps/reactjs/nextjs/nextjs-next-auth-integration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"webapps/reactjs/nextjs/nextjs-next-auth-integration/#untrustedhost-host-must-be-trusted-url-was-http00003000authsession-read-more-at-httpserrorsauthjsdevuntrustedhost","title":"UntrustedHost: Host must be trusted. URL was: http://0.0.0.0:3000/auth/session. Read more at https://errors.authjs.dev#untrustedhost","text":"<p>When the auth flow is triggered, it throws an <code>UntrustedHost</code> error:</p> <p>UntrustedHost: Host must be trusted. URL was: http://0.0.0.0:3000/auth/session. Read more at https://errors.authjs.dev#untrustedhost</p> <p>To fix it, for the time being, you need to expose <code>AUTH_TRUST_HOST</code> environment variable. This only happens in product build though.</p> <pre><code>AUTH_TRUST_HOST=http://localhost:3000\n</code></pre>"},{"location":"webapps/reactjs/nextjs/nextjs-next-auth-integration/#resources","title":"Resources","text":"<ul> <li>How to use NextAuth.js for client-side authentication in Next.js</li> </ul>"},{"location":"webapps/reactjs/nextjs/nextjs/","title":"NextJS","text":""},{"location":"webapps/reactjs/nextjs/nextjs/#use-react-router-with-nextjs","title":"Use React Router with NextJs","text":"<p>By default, nextjs uses its own path based routing mechanism and doesn't use the react-router framework. However, for some cases, it's desired to use the react-router along with NextJs. Here is an article about it:</p> <ul> <li>Building a single-page application with Next.js and React Router</li> <li>NextJs authentication</li> </ul>"},{"location":"webapps/reactjs/nextjs/nextjs/#initialization","title":"Initialization","text":"<ul> <li>[use effect to initialize the application]https://react.dev/learn/you-might-not-need-an-effect#initializing-the-application)</li> </ul>"},{"location":"webapps/reactjs/nextjs/nextjs/#understand-nextjs-config","title":"Understand nextjs config","text":"<ul> <li>What is the significance of the next.config.js file?</li> </ul>"},{"location":"webapps/reactjs/nextjs/nextjs/#docker-build","title":"docker build","text":"<p>The nextjs website has pretty good examples to showcase how to build a docker container for nextjs.</p>"},{"location":"webapps/reactjs/nextjs/nextjs/#error-handling","title":"Error Handling","text":"<ul> <li>This is a nice repo that showcased how local error boundary and global error can be created: https://github.com/milovangudelj/tests/</li> <li>also made a fork for my own: https://github.com/mgguo/nextjs-error-handling-tests</li> </ul>"},{"location":"webapps/vscode/vscode-setup/","title":"VSCode","text":""},{"location":"webapps/vscode/vscode-setup/#configure-vscode-settings-in-a-github-repository","title":"Configure vscode settings in a github repository","text":"<ul> <li>NextJS .vscode settings.json</li> </ul>"},{"location":"webapps/workflow/development-workflow/","title":"Development workflow","text":""},{"location":"webapps/workflow/development-workflow/#lint-and-formatting-setup","title":"Lint and formatting setup","text":"<ul> <li>https://levelup.gitconnected.com/effortless-pre-commit-linting-supercharging-your-next-js-13-project-with-husky-and-eslint-c79a26a10e96</li> <li>Implement git hooks using husky with commitlint in NextJs</li> </ul>"}]}