{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"My Own Runbooks","text":"<p>Use this to capture some useful notes during my day-to-day work.</p> <p>It's created with mkdocs.org, visit the website to see more details of it.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#setup","title":"Setup","text":"<pre><code>mkdocs new runbooks\nmkdocs get-deps\npip install mkdocs-material\nmkdocs serve\n</code></pre> <p>After the server starts, you can access the docs via http://localhost:8000</p>"},{"location":"#deploy-as-github-pages","title":"Deploy as github pages","text":"<p>Refer to mkdocs: deploy your docs</p> <pre><code># run this at the root of the repo\nmkdocs gh-deploy \n</code></pre> <p>After it's done, you can access the webiste with github-page/runbooks, or with other configurations: mingliang.me/runbooks.</p>"},{"location":"devops/secrets/generate_random_secrets/","title":"Generate random secrets","text":"<p>Use this handy website: Random key generator</p>"},{"location":"devops/ssl/generate_ssl_key_pairs/","title":"Generate SSL Key pairs for Https","text":""},{"location":"devops/ssl/generate_ssl_key_pairs/#steps-to-generate-the-key-pairs","title":"Steps to generate the key pairs","text":"<pre><code>openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout key.pem -days 366\n</code></pre> <p>After running the command above, it generates two files:</p> <ul> <li>cert.pem</li> <li>cert.pem</li> </ul> <p>These files will be used for your app as a self-signed key pairs.</p> <p>For example, a python FASTAPI service can use the self-signed certs as following(assuming the path is correct):</p> <pre><code>if __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", reload=True, port=8000, host=\"0.0.0.0\", ssl_keyfile=\"./certs/key.pem\",\n                ssl_certfile=\"./certs/cert.pem\")\n</code></pre>"},{"location":"devops/vagrant/","title":"Vagrant","text":""},{"location":"devops/vagrant/#vagrant-for-m1-macos","title":"Vagrant for M1 MacOS","text":"<p>There are two common options to run vagrant on Mac:</p> <ul> <li>VMWare Fusion as provider</li> <li>references: Installing Vagrant on Apple Silicon Macs (M1, M1X, etc)</li> <li>qemu as provider</li> <li>references: Do M1 Mac Dream of x86 Linux?</li> </ul> <p>The following example shows how to use qemu as the provider:</p> <pre><code>brew install qemu\nvagrant plugin install vagrant-qemu\nvagrant init -m perk/ubuntu-22.10-arm64\nvagrant up\n</code></pre>"},{"location":"frontend/react/react/","title":"ReactJS","text":""},{"location":"frontend/react/react/#useful-resources","title":"Useful resources","text":"<ul> <li>reactjs interview questions</li> </ul>"},{"location":"macos/macos/","title":"MacOS","text":""},{"location":"macos/macos/#window-management","title":"Window management","text":"<ul> <li>divvy</li> <li>rectangle</li> </ul> <p>Divvy is the one I have been using for years. It's good enough, not sure if it's worth to try something different. Heard some good words about <code>rectangle</code>, and also swish, which is a paid software.</p>"},{"location":"python/fastapi/fastapi/","title":"FASTAPI","text":""},{"location":"python/fastapi/fastapi/#useful-links","title":"Useful links","text":"<ul> <li>swagger</li> <li>enable https</li> </ul>"},{"location":"webapps/authNZ/auth-cli/","title":"Auth CLI","text":"<pre><code>curl -D 'https://dev-xyz.okta.com/oauth2/v1/token' \\\n-H 'Authorization: Basic base64-encoded-client_id:client_secret' \\\n-H 'content-type: application/x-www-form-urlencoded' \\\n-d 'grant_type=authorization_code' \\\n-d 'redirect_uri=http://localhost:3000' \\\n-d 'code=auth_code'\n</code></pre>"},{"location":"webapps/authNZ/auth-integration/","title":"AuthN/Z integration","text":""},{"location":"webapps/authNZ/auth-integration/#okta-integration","title":"Okta integration","text":"<ul> <li>okta cli</li> </ul>"},{"location":"webapps/authNZ/auth-integration/#install-okta-cli-on-macos","title":"Install okta cli on MacOS","text":"<pre><code>brew install --cask oktadeveloper/tap/okta\n</code></pre> <p>Setup a okta developer account(if not having one)</p> <pre><code>okta register\nokta login\nokta apps create\n</code></pre> <p>Once the okta app is created, the issuer, client ID, and client secret will be stored in an <code>.okta.env</code> file in your current directory.</p>"},{"location":"webapps/authNZ/auth-integration/#oauth-integration-options","title":"OAUTH integration options","text":""},{"location":"webapps/authNZ/auth-integration/#spa-with-okta","title":"SPA with OKTA","text":"<p>See docs from the official website: How Authentication and Authorization Work for SPAs</p>"},{"location":"webapps/authNZ/auth-integration/#okta-auth-related-urls","title":"OKTA Auth related URLs","text":"<ul> <li>well-known url: {Issuer}/.well-known/openid-configuration</li> <li>request userinfo: https://{okta_dev_account}.okta.com/oauth2/default/v1/userinfo</li> </ul> <p>CURL commands:</p> <pre><code>export JWT=your_access_token\ncurl -H \"Authorization: Bearer ${JWT}\" https://${okta_dev_domain}7.okta.com/oauth2/default/v1/userinfo\n</code></pre>"},{"location":"webapps/authNZ/auth-integration/#return-user-groups-in-okta-oauth-flow","title":"Return user groups in OKTA OAuth flow","text":"<p>According to this No \u2018groups\u2019 scope in the console for the default Authorisation Server</p> <p>By default, Okta doesn't have a <code>groups</code> scope defined, in order to use it and have users' group information returned in the token, you need to define both a scope and a claim for it. Here is the brief steps:</p> <ul> <li>In the authorization server, define a scope named <code>groups</code>, and toggle the option - <code>Include in public metadata</code>.</li> <li>Add a claim named <code>groups</code>, and make it include in <code>access token</code>, and set the filter as <code>matches regex</code> with value <code>.*</code>, and <code>Include in</code> the <code>groups</code> scope.</li> </ul>"},{"location":"webapps/authNZ/authNZ/","title":"Authentication and Authorization in Web Applications","text":"<p>There are two different ways to setup AuthNZ flow for a web application. </p> <p>A SPA + backend API configuration would require </p> <p>Follow this sample-js-react example from okta for the client side auth integration with okta, where the widget will be responsible for the signing via the okta auth flow and generate the access token in local storage if everything is good.</p> <p>The <code>okta-hosted-login</code> is exactly what we are looking for. It will initiate the login to okta and obtain the access token for subsequent request to the backend services.</p>"}]}